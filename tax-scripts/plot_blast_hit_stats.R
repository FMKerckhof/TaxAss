# Take in the blast table generated by find_seqIDs_with_pident.R
# Analyze the blast hits, are the best hits being chosen first?

# purpose: are blast settings OK, or are they not returning full length hits that would make our cutoff.


#####
# Receive arguments from terminal command line
#####

# userprefs <- commandArgs(trailingOnly = TRUE)
# blast.file.path <- userprefs[1]
# output.file.path <- userprefs[2]
# users.cutoff <- as.numeric(userprefs[3])
# user.wants.matches <- as.logical(userprefs[4])

blast.file.path <- "~/Desktop/hitstats.csv"
pident.cutoff <- 94

#####
# Install Necessary Packages
#####

# The package reshape is needed
#****CAN'T SUPPRESS ALL THESE STUPID WARNING MESSAGES!!!****
get.necessary.packages <- function(){
  if (library(package = "reshape", logical.return = TRUE) == FALSE){
    install.packages("reshape")
    library("reshape")
  }else{
    library("reshape")
  }
}

#####
# Define Functions for Handling Data
#####

# import the blast table generated in find_seqIDs_with_pident
import.BLAST.hits.table <- function(FilePath){
  blast.file.path <- FilePath
  blast <- read.csv(blast.file.path)
  return(blast)
}

# Trim blast table to only contain hits above the pident cutoff
apply.pident.cutoff <- function(BlastTable, PidentCutoff){
  blast <- BlastTable
  cutoff <- PidentCutoff
  
  index <- which(blast$true.pids >= cutoff)
  blast.cutoff <- blast[index,]
  
  return(blast.cutoff)
}

# find number of seqIDs from each hit #
reformat.fract.ids.vs.hit.num <- function(BlastTable){
  blast <- BlastTable
  
  # Only look at pident and hit.num
  blast <- blast[,c(2,8)]
  colnames(blast) <- c("qseqid","hit.num")
  blast <- apply(X = blast, MARGIN = 2, FUN = as.numeric)
  
  # Use the reshape package to rearrange your data tables
  blast <- as.data.frame(blast)
  # id is hit.num because that is the category we're arranging by
  # measured is qseqid because that is the variable we're applying the aggregate funciton to- what's the total #?
  blast.melted <- melt(data = blast, id.vars = "hit.num", measure.vars = "qseqid")
  blast.casted <- cast(data = blast.melted, formula = hit.num ~ variable, fun.aggregate = length)
  
  # Convert the qseqid length column to % total length/numbers
  blast.casted$qseqid <- blast.casted$qseqid / sum(blast.casted$qseqid) * 100
  colnames(blast.casted)[2] <- "perc.ids"
  return(blast.casted)
}

#####
# Define Functions for Plotting Data
#####
 
# bar plot blast hit number results
bar.plot.blast.results <- function(BlastHitsTable, Cutoff = 0){
  hits <- BlastHitsTable
  if (Cutoff == 0){
    barplot(height = hits$perc.ids, names.arg = hits$hit.num, ylim = c(0,100),
            main = "Which BLAST hit gave the best \"full length\" pident?\n(no cutoff pident applied)",
            xlab = "Hit Number", ylab = "Percent of Best Hits (%)", col = "lightsalmon")
  }else{
    barplot(height = hits$perc.ids, names.arg = hits$hit.num,
            main = paste("Which BLAST hit gave the best \"full length\" pident?\n(results with full length pident >=",Cutoff,")",sep=""),
            xlab = "Hit Number", ylab = "Percent of Best Hits (%)", col = "lightsalmon")
  }
}

# Make a stacked bar chart showing how the proportions change with different pidents
bar.plot.stacked.blast.results <- function(BlastTable, CutoffVector){
  blast <- BlastTable
  cutoffs <- CutoffVector
  num.hits.reported <- length(unique(blast$hit.num.best.ids)) # the highest blast hit number output into the table
  
  # create a matrix from which to plot a stacked bar chart
  hits.matrix <- matrix(data = 0,nrow = length(unique(blast$hit.num.best.ids)), ncol = length(cutoffs))
  colnames(hits.matrix) <- paste("pident", cutoffs, sep="")
  row.names(hits.matrix) <- paste("hit",1:num.hits.reported, sep="")
  
  # get hit stats for each cutoff
  for (c in 1:length(cutoffs)){
    trimmed.blast <- apply.pident.cutoff(BlastTable = blast, PidentCutoff = cutoffs[c])
    hits <- reformat.fract.ids.vs.hit.num(BlastTable = trimmed.blast)
    
    # at higher cutoffs some hits apear unreported, make sure these say zero so they fit in the matrix
    for (h in 1:num.hits.reported){
      index <- which(hits[,1] == h)
      if (length(index) > 0){
        hits.matrix[h,c] <- hits[index,2]
      }else{
        hits.matrix[h,c] <- 0
      }
    }
  }
  
  barplot(hits.matrix, ylim = c(0,100), col=rainbow(num.hits.reported),
          main = "Which BLAST hit gave the best \"full length\" pident?\n(remember blast reports hits in order of its \"alignment length\" pident",
          xlab = "Full length percent identity cutoff applied to blast results", 
          ylab = "Percent of best pidents resulting from each blast hit numbers (%)")
  
#   legend(x = num.hits.reported+1, y = 100, legend = row.names(hits.matrix), 
#          text.col = rainbow(length(num.hits.reported)))
}


# plot number of seqIDs at each hit #
line.plot.overlay.blast.results <- function(BlastTable, CutoffVector){
  blast <- BlastTable
  cutoffs <- CutoffVector
  
  # Set up a blank plot: 
  plot(0, type = "n", xlim = c(1,5), ylim = c(0,100), main = "Which BLAST hit gave the best \"full length\" pident?", 
       xlab = "Hit Number", ylab = "Percent of Best Hits (%)" )
  
  # Plot results for each cutoff
  for (c in 1:length(cutoffs)){
    trimmed.blast <- apply.pident.cutoff(BlastTable = blast, PidentCutoff = cutoffs[c])
    hits <- reformat.fract.ids.vs.hit.num(BlastTable = trimmed.blast)
    lines(hits, col = rainbow(length(cutoffs))[c])
    points(hits, col = rainbow(length(cutoffs))[c], pch = 19)
  }
  
  # Add a legend:
  legend(x = 4, y = 100, legend = sort(cutoffs, decreasing=T), text.col = rainbow(length(cutoffs))[length(cutoffs):1])
}
 
#####
# Use Functions
#####

get.necessary.packages()

blast <- import.BLAST.hits.table(FilePath = blast.file.path)

# View a table, 'hit.stats', that shows the percent of times each hit was best
hit.stats <- reformat.fract.ids.vs.hit.num(BlastTable = blast)
bar.plot.blast.results(BlastHitsTable = hit.stats)

# View a table, 'cutoff.hit.stats', that shows the percent of time each hit was best 
# after the blast results have been sorted for a given cutoff
pident.cutoff <- 97
blast.cutoff <- apply.pident.cutoff(BlastTable = blast, PidentCutoff = pident.cutoff)
cutoff.hit.stats <- reformat.fract.ids.vs.hit.num(BlastTable = blast.cutoff)
bar.plot.blast.results(BlastHitsTable = cutoff.hit.stats, Cutoff = pident.cutoff)

# View a plot of overlayed lines showing how the proportion of best hits changes with different cutoffs
line.plot.overlay.blast.results(BlastTable = blast, CutoffVector = 90:100)

# View stacked bar chart to see how the proportion of best hits changes with different cutoffs
bar.plot.stacked.blast.results(BlastTable = blast, CutoffVector = 50:100)

# Note how that plot levels off as you look way lower on the pidents.
# That's probably because that's where blast's built-in e-value cutoff
# stops reporting worse values, so worse hits aren't included in output.
